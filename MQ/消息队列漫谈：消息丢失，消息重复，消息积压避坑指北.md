#消息队列漫谈：关于消息丢失，消息重复，消息积压一些处理方式
作者：阿茂

说到消息队列对于不太熟悉它的原理的一些同学经常会遇到这样那样的坑，面试也会遇到一些，总结下来也就是消息丢失，消息重复，消息积压这三大类，只要了解它的原理这些问题我们就能处理个七七八八了。我们知道一条消息大致都要经历这么几个过程：生产者产生消息-->消息队列存储消息-->消费者消费消息。这个很重要，我们后面会围绕这三个过程来分析这些问题发生的原因与解决办法。

## 消息丢失
关于消息丢失这个问题，现在的这些消息队列中间件只要你正确配置基本都不会丢消息，但是万一出现了这种情况，我们需要知道从哪些地方着手来解决问题。一般消息丢失我们可以分为两大类：一类是网络丢失，还有一类是磁盘丢失。那么我们还是从上面的消息队列三个主要过程来分析：
1. 生产者把消息从Producer生产出来，经过网络发送给Broker端(生产阶段)：在这个阶段我们常用的保障手段就是，当Broker收到消息后给Producer一个确认响应（就是大家常说的ACK），如果Producer没有收到正确的响应，Producer直到收到Broker的确认响应后才会停止重试消息发送。这里需要注意的点是，根据自己业务场景有时候要对ACK做一些处理，消息队列大都提供了自动ACK，再需要手动确认ACK的时候我们需要关闭掉这一默认设置。还有就是需要在我们的代码处做好异常处理，尤其要注意在异步发送的回调中检查发送结果。这一就可以保证消息队列在这个阶段数据不会丢失。
2. Broker收到来自Producer的消息，持久化到磁盘（存储阶段）：在这个阶段只要Broker正常工作基本上都能序列化正常，但是在集群化的Broker中发生概率还是比较高的。因此我们要对刷盘机制根据情况做一些调整，在单节点的情况下，我们可以设置当Broker接收到消息后先刷盘，当刷盘成功后再给Producer成功响应。这样即使Broker宕机，由于消息已经写入磁盘，重启后会继续处理，这里就会引入一个新的问题我们接下来会说到（消息重复）。例如设置RocketMQ中flushDiskType=SYNC_FLUSH（同步刷盘）
3. 消费者通过网络，从Broker上读取消息（消费阶段）：在这个阶段我们需要注意的一定要当消费者处理完你自身业务逻辑后给Broker发送消费确认。否则当你收到消息就给Broker确认消费，此时Broker认为消费者消费成功，将消息从Broker队列中移除，当本地逻辑处理异常时就很有可能丢掉这个消息。
## 消息重复
上面我们说到了消息丢失的处理方式，大家有没有发现有好几个地方是有问题呢？问题就是：当我们保证了不丢消息的同时，又引入了消息重复的问题。在一定情况下当消费者消费成功后再ack时异常或者超，Broker此时会认为此消息未消费成功，进入重复消费阶段。其实现在解决这个问题就显得非常简单了，我们不管是生产者重复，还是Broker重复我们只要在消费端保证幂等性就可以（任意多次执行所产生的影响均与一次执行的影响相同称为幂等操作），当然我们这里说的是少量的因为系统异常导致的消息重复，因为业务异常出现大量重复消息，虽然也可以通过这个办法来解决，但是并不是最有效的办法。我们在设计系统时候不管是否会有重复消息，在消费端保证幂等性是我们必须要做的，防患于未然嘛。下面我就介绍几种常用的保证幂等性的方法：
1. 通过数据库的为唯一键实现幂等：我们可以在设计消息结构的时候设置一个对应数据库唯一键的列字段，业务成功后将此字段作为唯一键报错入数据库。当同样的ID做保存的时候就会出现违反数据库唯一约束异常，这里的主键可以是单独的，也可以是组合的列。这种方式可以在任何支持“INSERT IF NOT EXIST”的存储系统中适用。
2. 通过版本号/数据快照实现幂等：其实这种方式有点类似于乐观锁的实现方式，就是需要消息中带有此业务当前一个瞬时状态的值，通过这个值与业务当前数据比较来判断是否执行更新操作。比如有一条重复的消息是这样的：将订单号为00001的状态从01变更为02（当订单00001的状态为01就改为02），这样一条重复的消息进来是不会对00001的订单做任何影响的。此时状态就是一个前置条件。再比如：将商品A的库存从500中减1（当商品A的总库存为500则减1）。类似这些需要在设计消息结构的时候带上一些业务属性活数据。另外一种办法就是给消息增加一个类似数据库的version字段，在每次消费更新的时候比较当前数据的版本号是否与消息中带的版本号一致，来判断是否执行消费。
3.全局唯一ID：当一条重复的消息发送到不同的消费者时候，貌似上面的办法都不怎么管用的。这就是所谓的分布式集群中出现的重复消息并行问题，你得保证一个健壮的全局唯一发号器，然后在每次操作之前判断此ID是否已经被别的消费者消费过。当然你要没有一个健壮的全局唯一ID发号器，那么我建议你可以通过消息路由规则。将某也业务的消息存储在同一个队列主题中。（比如通过user_id，order_id将消息业务消息分发到同一个Broker的队列中，这样就既利用了集群资源，又将问题回归到上面两张处理方式了）

像上面说到的通过某一种消息发送路由规则这样既能解决消息并行中存在多重问题，而且还能保住消息的业务局部有序性，这种方式值得大家思考下。
##  消息积压
其实对于一个原本正常的消息系统来说消息积压，只会出现两张情况：要么生产者消息数量增加导致的积压；要么就是消费者消费变慢导致的消息积压。问题也很显而易见：要么就是流量突然增加，要么就是业务逻辑异常。对于一个消息队列我们肯定在上线前就预估好，单节点最大承受流量与系统目前最大峰值流量的数据，