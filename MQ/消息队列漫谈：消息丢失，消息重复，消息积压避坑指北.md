#消息队列漫谈：关于消息丢失，消息重复，消息积压一些处理方式
作者：阿茂

说到消息队列对于不太熟悉它的原理的一些同学经常会遇到这样那样的坑，面试也会遇到一些，总结下来也就是消息丢失，消息重复，消息积压这三大类，只要了解它的原理这些问题我们就能处理个七七八八了。我们知道一条消息大致都要经历这么几个过程：生产者产生消息-->消息队列存储消息-->消费者消费消息。这个很重要，我们后面会围绕这三个过程来分析这些问题发生的原因与解决办法。

## 消息丢失
关于消息丢失这个问题，现在的这些消息队列中间件只要你正确配置基本都不会丢消息，但是万一出现了这种情况，我们需要知道从哪些地方着手来解决问题。一般消息丢失我们可以分为两大类：一类是网络丢失，还有一类是磁盘丢失。那么我们还是从上面的消息队列三个主要过程来分析：
1. 生产者把消息从Producer生产出来，经过网络发送给Broker端：在这个阶段我们常用的保障手段就是，当Broker收到消息后给Producer一个确认响应（就是大家常说的ACK），如果Producer没有收到正确的响应，Producer直到收到Broker的确认响应后才会停止重试消息发送。这里需要注意的点是，根据自己业务场景有时候要对ACK做一些处理，消息队列大都提供了自动ACK，再需要手动确认ACK的时候我们需要关闭掉这一默认设置。还有就是需要在我们的代码处做好异常处理，尤其要注意在异步发送的回调中检查发送结果。这一就可以保证消息队列在这个阶段数据不会丢失。
2. Broker收到来自Producer的消息，持久化到磁盘：在这个阶段只要Broker正常工作基本上都能序列化正常，但是在集群化的Broker中发生概率还是比较高的。因此我们要对刷盘机制根据情况做一些调整，在单节点的情况下，我们可以设置当Broker接收到消息后先刷盘，当刷盘成功后再给Producer成功响应。这样即使Broker宕机，由于消息已经写入磁盘，重启后会继续处理，这里就会引入一个新的问题我们接下来会说到（消息重复）。例如设置RocketMQ中flushDiskType=SYNC_FLUSH（同步刷盘）
