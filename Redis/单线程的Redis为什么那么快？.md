#单线程的Redis为什么那么快？
作者：阿茂

##上期回顾
上一篇文章刚一发出去，就有朋友问我：既然布隆过滤器是概率性的，在极端情况下数据库有的缺被你判没了怎么办？那它的优点是什么？在上一篇文章中确实这种方面说的比较少，这里我就说说我自己的看法吧。首先你使用布隆过滤器判“包含”的时候就存在有损业务数据的可能性，这个也就是需要使用者对自身业务有损的容忍度。我们可以根据上篇文章提到的公式设计一个自己系统能容忍的误判率，就可以了。我们再说说它适合在什么场景使用：还是我们上一篇的推送给用户信息的例子，如果使用常规方式那么你得维护一套持久化的发送对应关系，每次需要查找出未推送的用户，这一步就需要较多的内存或者磁盘资源，如果使用一个误判小于0.1%布隆过滤器的话，也就是可能会存在小于0.1%的用户未收到推送消息，根据业务场景两者相比取最优就可以了。还有对于修改布隆过滤器的操作，为了保证不重置掉别的key至少需要两个以上hash函数。另外，要是把布隆过滤器当做一个整数计数数组使用的话我建议大家可以参考下：Redis HyperLogLog数据类型，它的使用很方便灵活，但原理有点复杂。

## Redis为什么那么快
这一篇我们说一说Redis的单线程设计模式何以让每条指令支持上单机10万的并发的（标准硬件配置下）。首先他是基于纯内存的操作，在寻址过程上要比磁盘快的就不是一个量级。然后就是它的非阻塞线程IO模型，能够将连接请求的吞吐量提升到极致，最后就是它自身的一套简洁的序列化方式。当然它良好的性能不仅限于此，下面我们就来着重说说线程模型，跟序列化方式。
>对于面试官你只要大致说出下面四条就可以了：
>1. 它是存内存操作；
>2. 核心是基于非阻塞的IO多路复用机制；
>3. 单线程的设计避免了多线程上下文切换的资源开销；
>4. 简单且解析性能高的序列化协议。

那么对于高级的一点面试现场看我下面详细的道来
### 非阻塞的IO多路复用机制
其实这个它是两个概念，非阻塞IO,多路复用（事件轮询）。这个是典型的Reactor模型
### 非阻塞IO
阻塞和非阻塞很好理解，比如一个read请求要读固定长度的内容，如果没有读够线程就会一直等待新的数据到来或者超时关闭链接，read请求才能够返回，线程才能继续处理。write请求一般是不会阻塞的，除非链接缓冲区已经满了，write请求才会阻塞，直到缓冲区有新的空间才会写完返回。有了非阻塞IO意味着在读写的时候不必阻塞，读写可以瞬间完成后就可以去干别的事情了，能读/写多少是多少。
### 


