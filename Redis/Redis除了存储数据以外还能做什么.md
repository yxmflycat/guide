# Redis除了存储数据以外还能做什么
作者：阿茂

前五篇文章我带大家了解了Redis的一些基础知识与架构原理性到的东西，这一篇我们来讨论下Redis除了当做存储服务以外还能做些什么，这也是出去面试会被经常问到的问题。下面我们来了解一下一些常用的应用：
## 分布式锁
基本上出去面试都会被提及到Redis分布式锁的应用，那么它是怎么实现的呢？分布式系统经常会遇到处理并发的问题，当一个资源有多个线程统一时间读写时，要保证最终数据的正确性，说白了就是要保证操作的原子性。我们总体的原则就是：当别的线程操作共享资源时，发现已经有人声明说这个资源我正在使用且没有用完的时候，此线程只能等待或者放弃。在Redis里面我们一般会使用setnx对资源加锁，当资源使用完毕，发送一条del指令释放锁，方便别的线程使用此资源。说起来好像就这么一句话，但是在实际使用中存在着种种要考虑的问题，比如应用处理逻辑出现异常并未执行del命令，这样就会陷入死锁永远将资源无法释放。在早期的2.8以前版本setnx与expire是两条指令而不是一个原子操作，服务器出现意外就会造成频繁的死锁，那么这时候有同学就会想到用事务来保证setnx与expire指令的原子性，但是expire是依赖于setnx的返回结果的，假如setnx并未抢占到资源锁，expire该不该执行呢？事务的特性就是要么都执行要么都不执行。当2.8以后引入setnx的超时时间参数以后就方便多了，那么通过一条新引入 的指令这样就彻底解决了Redis分布式锁了？那说明你还没考虑到各种问题：

- 分布式超时：Redis的分布式锁不能解决超时问题，如果在加锁与释放的处理逻辑或者网络抖动造成的耗时大于了锁超时时间，那么这时候资源将不受当前线程的控制，第二个线程就会重新持有了此资源的锁，当第一个线程再将处理结果更新时，此时资源版本与它持有的资源版本已经不一致了，但是线程一还认为这是自己持有的锁将其删除，就会导致马上有第三个线程进入持有锁，这样循环错误下去。为了避免这个问题，我们尽量在设计锁的时候考虑到线程正常处理耗时（排除网络抖动造成的）与锁超时时间的合理值，当偶发的网络抖动造成的超时，我们可以给value设置一个唯一随机ID值（例如：客户端标识+时间戳+随机值），释放锁时先查看是否跟客户端持有的唯一id一致，再删除锁。一般情况下我们可以在客户端做逻辑处理，当发出del命令时候发现跟自己持有的随机数不一致时就认为加锁操作失败，回滚当前操作，再从新尝试获取锁。但是这又存在一个问题，比较操作跟删除操作又不是一个原子操作，这就需要我们通过Redis的Lua脚本来定义一个原子操作，因为Lua脚本的操作可以保证原子性（关于Lua脚本的使用我们这里就不展开解释了，大家可以自行查阅与学习）。
- 可重入问题：要支持同一个线程的多次加锁，我们需要重写客户端的set方法，例如Java中的ReentrantLock，使用线程Threadlocal将加锁次数保存起来，具体实现可以见JKD的ReentrantLock的实现
- 分布式节点切换数据延迟问题：在分布式集群环境中经常会遇到主从切换，假如从节点转化为主节点时锁信息还未同步到新的主节点的时候或者在极端情况下锁信息丢失，又会导致资源使用混乱的问题。虽然这是很少见的情况但是为了保证4个9的可用性我们还是需要考虑的。为了解决这个问题我们需要了解下Redlock算法。使用 Redlock，需要提供多个Redis实例，这些实例之前相互独立没有主从关系，跟市面上分布式架构一样，都采用大多数原则，加锁时会向大多数节点发送set(key, value, nx=True, ex=xxx)指令，成功后就认为加锁成功，释放锁时需要向全部节点发送del指令。因为牵扯到多个节点的交互所以这个锁的代价还是很大的。这个算法也并不是完美的，在使用时还是要考虑到系统的有损容忍度，具体Redlock算法大家可以参考如下文章：
> - How to do distributed locking：'http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html'
## 事务
我们可以通过Redis的特性来实现一个简单的事务，只要是事务都要满足acid特性，但是在使用Redis事务的时候要注意一些问题。Redis收到一系列事务指令的时候不是马上执行的，它会缓存在Redis的事务队列里面，等待exec指令的到来才开始执行整个事务，因为Redis是单线程的在队列不用担心指令顺序混乱。从我们上面的描述大家应该就能发现问题，真正的事务要么是一起执行，要么一起失败，但是在Redis里面从队列里面出来事务指令会一个个执行，如果一个执行出现异常，那么Redis并没有提供类似Mysql那样的undoLog的机制让事物回滚，仅仅只提供了discard丢弃指令，用于丢弃事务队列里面的事务（在exec之前）。所以它就不含有原子性的特性。只能保证可靠到的隔离性（当前事务不被其他事务打断）。我们可以通过客户端指令合并尽量保证指令的原子性，也就是我们之前所说的管道概念（pipeline），将多次IO压缩成一次。当然我们可以使用另外一种变通的使用方式：Redis的watch机制，在事务开启之前监听某些关键变量，当事务执行时（执行exec指令）比较自己持有的资源版本是否自监听以来有变化，如果有变化那么就执行失败discard丢弃指令并返回客户端，让客户端重试，否则执行。以上都是一些弥补办法，要想使用完整且强大的事务特性还得寻求别的中间件。当然了解这一特性有助于设计出更好的系统。
## 消息队列
Redis的消息队列也如同它的事务功能，不是专业的消息中间件，并没有像kafka，Rabbitmq这些消息队列那么强大，也不没有ack机制，但是要你只想要一个简单的消息队列，不需要那么多附带功能，那么它就是你的首选。Redis的消息队列是使用list数据结构来实现的，list数据结构它本身就一个链表有着极强的顺序性。可以使用rpush/lpush入队， lpop/rpop出队。如果队列空了我们会让客户端会陷入pop死循环或者sleep后再pop这样的循环中，这样明显的问题就是，当sleep时间设置过长，会导致消息到来时延迟，当sleep时间过短的话又会导致服务端压力过大。这种情况下最好使用blpop/brpop，它们是指使用blocking（阻塞读），在队列里没有数据时候处于blocking状态，当数据到来线程马上就会进入处理数据。需要注意的是当使用blpop/brpop的时候，长时间处于空闲状态服务端会主动断开连接，在客户端需要做个异常处理，再重试。除了以上使用list数据结构还可以使用zset数据结构实现简单的消息队列，把消息内容序列化成字符串存储在value中。它唯一的特点就是可以让消息带有优先级，比如可以实现一个设置一个优先字段作为score，然后客户端优先处理score高的。还有就是可以实现一个延迟队列，执行时间作为score，比如用户下单后2小时发送订单状态消息这样的需求。
## 位图
这种数据结构一般作为优化数据量很有效果的，比如什么签到，报名，投票这样的统计类的功能，你如果使用数据既要存储用户和对应的操作以及时间等其他的信息，当用户量巨大的的时候，将给你带来很大的烦恼。Redis的位图结构我们在之前的数据结构篇有讲过，这里我们在提一下，它是一个byte数组，我们可以使用get/set直接设置跟读取整个位图的值，也可以使用位图操作getbit/setbit等将byte数组当做位数组来处理。Redis的位数组是自动扩展的，如果设置了阈值且当前超出了阈值会自动将数组进行扩充，还可以使用bitcount实现快速统计，使用位图查找指令bitpos查找某范围的位图值，两个指令也可以组合使用对某个范围的位图值进行统计。比如查找一个用户一年中每周末签到数总和。