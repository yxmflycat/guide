# Redis除了存储数据以外还能做什么
作者：阿茂

前五篇文章我带大家了解了Redis的一些基础知识与架构原理性到的东西，这一篇我们来讨论下Redis除了当做存储服务以外还能做些什么，这也是出去面试会被经常问到的问题。下面我们来了解一下一些常用的应用：
## 分布式锁
基本上出去面试都会被提及到Redis分布式锁的应用，那么它是怎么实现的呢？分布式系统经常会遇到处理并发的问题，当一个资源有多个线程统一时间读写时，要保证最终数据的正确性，说白了就是要保证操作的原子性。我们总体的原则就是：当别的线程操作共享资源时，发现已经有人声明说这个资源我正在使用且没有用完的时候，此线程只能等待或者放弃。在Redis里面我们一般会使用setnx对资源加锁，当资源使用完毕，发送一条del指令释放锁，方便别的线程使用此资源。说起来好像就这么一句话，但是在实际使用中存在着种种要考虑的问题，比如应用处理逻辑出现异常并未执行del命令，这样就会陷入死锁永远将资源无法释放。在早期的2.8以前版本setnx与expire是两条指令而不是一个原子操作，服务器出现意外就会造成频繁的死锁，那么这时候有同学就会想到用事务来保证setnx与expire指令的原子性，但是expire是依赖于setnx的返回结果的，假如setnx并未抢占到资源锁，expire该不该执行呢？事务的特性就是要么都执行要么都不执行。当2.8以后引入setnx的超时时间参数以后就方便多了，那么通过一条新引入 的指令这样就彻底解决了Redis分布式锁了？那说明你还没考虑到各种问题：

- 分布式超时：Redis的分布式锁不能解决超时问题，如果在加锁与释放的处理逻辑或者网络抖动造成的耗时大于了锁超时时间，那么这时候资源将不受当前线程的控制，第二个线程就会重新持有了此资源的锁，当第一个线程再将处理结果更新时，此时资源版本与它持有的资源版本已经不一致了，但是线程一还认为这是自己持有的锁将其删除，就会导致马上有第三个线程进入持有锁，这样循环错误下去。为了避免这个问题，我们尽量在设计锁的时候考虑到线程正常处理耗时（排除网络抖动造成的）与锁超时时间的合理值，当偶发的网络抖动造成的超时，我们可以给value设置一个唯一随机ID值（例如：客户端标识+时间戳+随机值），释放锁时先查看是否跟客户端持有的唯一id一致，再删除锁。一般情况下我们可以在客户端做逻辑处理，当发出del命令时候发现跟自己持有的随机数不一致时就认为加锁操作失败，回滚当前操作，再从新尝试获取锁。但是这又存在一个问题，比较操作跟删除操作又不是一个原子操作，这就需要我们通过Redis的Lua脚本来定义一个原子操作，因为Lua脚本的操作可以保证原子性（关于Lua脚本的使用我们这里就不展开解释了，大家可以自行查阅与学习）。
- 可重入问题：要支持同一个线程的多次加锁，我们需要重写客户端的set方法，例如Java中的ReentrantLock，使用线程Threadlocal将加锁次数保存起来，具体实现可以见JKD的ReentrantLock的实现
- 分布式节点切换数据延迟问题：在分布式集群环境中经常会遇到主从切换，假如从节点转化为主节点时锁信息还未同步到新的主节点的时候或者在极端情况下锁信息丢失，又会导致资源使用混乱的问题。虽然这是很少见的情况但是为了保证4个9的可用性我们还是需要考虑的。为了解决这个问题我们需要了解下Redlock算法。使用 Redlock，需要提供多个Redis实例，这些实例之前相互独立没有主从关系，跟市面上分布式架构一样，都采用大多数原则，加锁时会向大多数节点发送set(key, value, nx=True, ex=xxx)指令，成功后就认为加锁成功，释放锁时需要向全部节点发送del指令。因为牵扯到多个节点的交互所以这个锁的代价还是很大的。这个算法也并不是完美的，在使用时还是要考虑到系统的有损容忍度，具体Redlock算法大家可以参考如下文章：
> - How to do distributed locking：'http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html'
- 总结：其实在分布式锁的使用场景中，有两种第一种就是带资源的锁，和不带资源的单纯锁。