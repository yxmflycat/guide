# MySql那些事儿（八）：一篇文章搞懂事务的隔离性与隔离级别
作者：阿茂

从今天开始我们来填之前Mysql系列文章的坑，这一篇文章我们来聊一聊Mysql的事务隔离性与隔离级别，这个概念是面试基本上涉及到Mysql问题必问的问题。接下来跟我一起来梳理下相关概念，让你在面试中游刃有余，在平时工作中少踩坑。提到事务我就得碎碎念ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），而这里我们说的就是其中的“隔离性”。当我们在同一个数据库中同时执行多个事务时就会出现：脏读，不可重复读，幻读的问题，为了解决这个问题，数据库中就有了隔离级别的概念。常规的隔离级别包括：读未提交，读提交，可重复读，串行化。
> 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到；
> 读提交：一个事务提交之后，它做的变更才会被其他事务看到；
> 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时（所有已提交数据）看到的数据是一致的；
> 串行化：就是同一行记录在被事务读写时，通过互斥方式保证同一时刻只有一个事务执行，其他事务处于阻塞中。
##  事务隔离的实现与MVCC
关于事务的隔离性实现，这里将通过“可重复读”展开说明。事务在启动的时候会为每一个事务创建一个read-view（也称之为“事务快照”）并且数据系统会给它分配一个全局唯一的递增ID称之：transaction id。每个事务来更新这一行数据时，都会产生一个数据版本，并且把transaction id赋值给当前数据版本的事务ID，称之：row trx_id。与之同时回保留旧版本数据日志（undo log），在新版本中的roll_pointer指向旧版本id。也就是说一行记录可能会有多个版本，每个版本都会有自己的row trx_id。这里说明一下，数据版本只是一个逻辑概念，而不是物理存在的。它可以通过当前版本的undo log依次计算出之前每个数据版本（read-view）的数据与版本信息。我们在本系列文章《MySql那些事儿（五）：事务是个什么东西？》中介绍了关于read-view的一些属性说明，有了这些概念就很好判断某个版本是否可见：
1. 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问；
2. 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明该版本生成的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问；
3. 如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问；
4. 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版
   本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性。这里需要注意点的是，每种隔离事务隔离级别创建生成read-view的时机是有所区别的。READ COMMITTD在每次进普通SELECT操作前都会成个ReadView，REPEATABLE READ只在第次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。
>总结：执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。而insert语句却不需要支持MCVV，所以在事务提交后就被释放掉了。
## 关于幻读
幻读解释过来就是：如果一个事务先根据某些条件查询出这些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读。这里我们还是要针对不同隔离级别来说明，在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。一个事务的结果被另一个事务查询到时的当前读，不能称之为幻读，幻读仅指‘新插入的行’。
### 关于幻读的问题
哪怕你在update时候使用for update行锁也阻止不了幻读的发生，因为你for update的只是存在的数据，而未来提交的新数据缺不在你的for update 范围。
### 幻读的解决
现在你知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)，顾名思义，间隙锁，锁的就是两个值之间的空隙。
假如我有如下这张表

```mysql
insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。