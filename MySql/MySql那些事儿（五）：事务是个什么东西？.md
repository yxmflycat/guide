# MySql那些事儿（五）：事务是个什么东西？
作者：阿茂

上一篇文章我们说了索引，收到有些朋友的提问，其中有这么一个问题：datetime类型的数据列索引怎么创建？我们在这里简单的说一下吧，因为datetime类型的类索引处理确实是注意下，我就说几种方式吧。最优处理办法就是把传入的datetime值转换成整型去和数据库列作比较。这样的就需要程序里面做一次转换，还有一只就是直接用时间字符串比较‘2019-11-01 13:05:13’，使用FROM_UNIXTIME()函数却是里面最慢的一种方式。大家可以去试试。还有一种就是在index(dateTime)的索引上添加函数，让它索引按字符串创建例如可以这样convert(ndex(dateTime),'partten')去创建索引。就和其他索引的使用方式一样了。好了上回内容就说道这，大家有什么问题或者好的想法可以私信或者留言给我，我会尽全力回答。

这篇文章我们说下事务，简单的说就是保障一组数据库操作要么一起成功，要么一起失败的机制。最经典的例子就是银行转账操作，既要保证转账人账户和收款人账户正确还要保证银行流水完整，交易可以回溯，其中环节缺一不可。事务的支持是在数据库引擎层面的，并不是所有的引擎对事务都有良好的支持。比如MyISAM,Memory。那么它是通过什么样的设计来保证的呢？（这里说个题外话，希望大家多看看原理性的东西，最终看下来你会发现现在很多中间件，这框架，那框架底层设计算法都是大同小异）
### 事务的工作原理

InnoDB的为了支持事务而单独引入了undo log和redo log两个概念来实现事务的回滚和写入，保证事务的一致性。redo log为了提高吞吐量还提供了纯内存的redo log buffer。InnoDB是采用Write Ahead Log策略（先写日志再写磁盘），当一条记录写入是，它会先写入redo log buffer的内存中，我们可以手动设置刷盘参数innodb_flush_log_at_trx_commit，将redo log buffer的内容通过后台线程更新到redo log file中去。redo log是固定大小，固定数量循环写入的一个闭环，通过checkpoint值往前推进，当写到结尾时，将头部的文件刷到磁盘后重新开始写入，异常重启后根据checkpoint可以继续将赃页刷新到磁盘。 可以通过参数innodb_log_files_in_group 和 innodb_log_file_size 配置日志文件数量和每个日志文件的大小。偶尔我们会发现某个时段Mysql服务器好像卡了一下，大概率的就是在刷赃页到数据库。
> innodb_flush_log_at_trx_commit参数说明
> - 0:表示每次事务提交时都只是把redo log留在redo log buffer中。
> - 1:表示每次事务提交时都将redo log直接持久化到磁盘。
> - 2:表示每次事务提交时都只是把redo log写到System page cache。

Buffer pool中的内容页跟磁盘页的内容不一致我就称之为赃页。实际上除了后台线程轮询刷新还有几个场景场景会将赃页刷新到磁盘，其中前两种情况会将一个未提交事务写入磁盘：
> - redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动将数据写到System cache
> - 并行的事务提交的时候，会一起将事务的redo log buffer持久化到磁盘。（就是上面说到的innodb_flush_log_at_trx_commit参数为1的时候）
> - Mysql进程正常关闭或者空闲的时候