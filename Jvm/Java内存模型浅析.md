在面试过程中经常会被问到Java内存模型，那么Java的内存模型是个啥子呢？今天我们大致讲解一下基于HotSpot的内存模型，很多细节处我们需要另外展开来讨论，这里只是把基本涵盖到大致的说一下。

## Java内存模型(JavaMemoryModel)定义
描述了Java程序中各种变量在线程中的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量的底层细节。规定了所有共享实例变量，类变量都必须存储于主内存中，线程对变量的所有的读写操作都必须在自己的工作内存中完成，不能直接在主内存中操作。不同线程之间是不能直接相互访问各自工作内存中的变量。线程间变量值传递都需要主内存来完成，线程、主内存、工作内存三者的交互关系如图所示：
![](../resource/内存模型.png)
> 内存操作指令：
> - lock：作用于主内存的变量指令，它把一个变量标识为一个线程独占的状态；
> - unlock：作用于主内存的变量指令，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；
> - read：作用于主内存的变量指令，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load指令使用。
> - load：作用于工作内存的变量指令，它把read指令从主内存中得到的变量值放入工作内存的变量副本中。
> - use：作用于工作内存的变量指令，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个指令。
> - assign：作用于工作内存的变量指令，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个指令。
> - store：作用于工作内存的变量指令，它把工作内存中一个变量的值传送到主内存中，以便随后的write指令使用。
> - write：作用于主内存的变量指令，它把store指令从工作内存中得到的变量的值放入主内存的变量中。
## Java内存模型(JavaMemoryModel)三大特性
Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，我们逐个来看一下哪些操作实现了这3个特性的。
### 原子性
由Java内存模型来直接保证的原子性变量指令包括 read、load、assign、use、store 和 write，我们大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java 内存模型还提供了 lock 和 unlock 指令来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性。或者使用JDK的原子类
> 关于long和double变量的特殊规则:
> Java内存模型要求上面那8个缓存操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read 和 write 这4个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定（Nonatomic Treatment ofdouble and long Variables）
### 可见性
可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。除了volatile我们还能使用两个关键字能实现可见性：
- synchronized：对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）
- final：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this(this引用逃逸有可能使线程通过这个引用访问到“初始化了一半”的对象，还是需要引起注意)的引用传递出去,那在其他线程中就能看见final 字段的值。

关于volatile变量在线程间可见的话是如何保证其一致性的呢？为了解决这个问题各种处理器厂商提供一些操作协议来保证数据的一致性，例如：MESI，MSI，MOSI，Synapse等。我们这里就简单说一下Inter的MESI协议吧：
#### MESI（缓存一致性协议）
当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。它是通过如下嗅探方式来发现数据失效的：
> 嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。如果在程序中大量使用volatile，由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值。这就是传说中的总线风暴。至于什么时候去使用Volatile什么时候使用锁，根据场景区分。




## 关于volatile不得不说那些事儿
当一个变量被volatile修饰后在线程间他将具备两个特性：可见性，禁止指令重排。那么我们下面就对这两个特性展开来说：
### 可见性
当一个线程修改了volatile变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是 Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们仍然需要通过加锁（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。那么
> 我们可以通过如下判断来确定是否加锁
> - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值;
> - 变量不需要与其他的状态变量共同参与不变约束。
### 禁止指令重排序优化

